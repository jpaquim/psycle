#! /usr/bin/env waf

import os, os.path, Options

APPNAME = 'waf-test'
VERSION = '1.2.3'

srcdir = '.'
blddir = '++build'

class G(object):
	def __init__(self):
		self.lib_version_symlinks = []
g = G() # :-(

def lib_version_symlinks(path, name, version):
	global g # :-(
	g.lib_version_symlinks.append((path, name, version))

def do_lib_version_symlinks():
	if Options.platform.startswith('win'): return
	global g
	lib_version_symlinks = g.lib_version_symlinks
	for path, name, version in lib_version_symlinks:
		path_name = os.path.join(path, name)
		clean = Options.commands['clean']
		if clean or not os.path.islink(path_name):
			name_version = name + '.' + version
			path_name_version  = path_name + '.' + version
			path_name_version1 = path_name + '.' + version[:version.find('.')]
			if not clean and os.path.exists(path_name):
				os.rename(path_name, path_name_version)
				os.symlink(name_version, path_name_version1)
				os.symlink(name_version, path_name)
			else:
				os.unlink(path_name_version1)
				os.unlink(path_name_version)

		return
		if os.path.exists(path_name):
			if not os.path.islink(path_name):
				name_version = name + '.' + version
				os.rename(path_name, os.path.join(path, name_version))
				os.symlink(name_version, path_name + '.' + version[:version.find('.')])
				os.symlink(name_version, path_name)
		elif 'clean' in Options.commands:
			name_version = name + '.' + version
			os.unlink(path_name + '.' + version[:version.find('.')])
			os.unlink(os.path.join(path, name_version))

def init():
	pass

def set_options(opt):
	opt.tool_options('compiler_cxx')

def configure(conf):
	conf.check_tool('compiler_cxx')

def deep_dirs(bld, dirs):
	deep_dirs = []
	for dir in [bld.path.find_dir(d) for d in dirs]: deep_dirs += deep_dir_nodes(bld, dir.dirs())
	return dirs + deep_dirs

def deep_dir_nodes(bld, dir_nodes):
	deep_dirs = []
	for dir in dir_nodes: deep_dirs += deep_dir_nodes(bld, dir.dirs())
	return deep_dirs + dir_nodes

def deep_sources(bld, cxx_taks_gen, sources):
	cxx_taks_gen.source = []
	for s in sources:
		#print 'source search:', s
		node = bld.path.find_resource(s) # is it a file?
		if node: cxx_taks_gen.source.append(s)
		else:
			node = bld.path.find_dir(s) # is it a dir?
			cxx_taks_gen.find_sources_in_dirs([d.relpath_gen(bld.path) for d in deep_dir_nodes(bld, [node])])
	#print 'found source files:', cxx_taks_gen.source

def module(bld, target, kind, types = 'shared', sources = None, includes = None, headers = None, uselib_local = None, uselib = None):
	for type in types:
		if kind == 'program':
			obj = bld.new_task_gen('cxx', 'program')
			obj.target = target
			if len(types) > 1: obj.target += '-' + type
		else:
			obj = bld.new_task_gen('cxx', type == 'static' and 'staticlib' or type == 'shared' and 'shlib')
			obj.target = target
			if type == 'shared':
				global VERSION
				############obj.vnum = VERSION
				############lib_version_symlinks(os.path.join(bld.bdir, obj.env.variant()), 'lib' + obj.target + '.so', obj.vnum)
		obj.name = target + '-' + type
		deep_sources(bld, obj, sources)
		obj.includes = includes
		if type != 'static': obj.rpath = '\\$ORIGIN:\\$ORIGIN/../lib'
		if uselib_local: obj.uselib_local = [u + '-' + type for u in uselib_local]
		if uselib: obj.uselib = [u + '-' + type for u in uselib]
	if kind != 'program':
		if headers is None:
			headers = []
			# we search headers in source dirs
			for s in sources:
				node = bld.path.find_resource(s) # is it a file?
				if node: node = node.parent # we add headers from where the source file located
				else: node = bld.path.find_dir(s) # is it a dir?
				headers.append(node.relpath_gen(bld.path))
		install_headers(bld, includes, headers)

def program(bld, target, types = 'shared', sources = None, includes = None, uselib_local = None, uselib = None):
	module(bld, target, 'program', types, sources, includes, None, uselib_local)

def lib(bld, target, types = 'shared', sources = None, includes = None, headers = None, uselib_local = None, uselib = None):
	module(bld, target, 'lib', types, sources, includes, headers, uselib_local)

def install_headers(bld, includes, headers):
	headers_filenames = []
	for h in headers:
		#print 'header search:', h
		node = bld.path.find_resource(h) # is it a file?
		if node: headers_filenames.append(h)
		else:
			node = bld.path.find_dir(h) # is it a dir?
			if node:
				for dir in deep_dir_nodes(bld, [node]):
					bld.rescan(dir)
					if False: # only lists .cpp files ... bug in waf?!
						print 'dir:', dir.abspath()
						for child in dir.childs.values(): print 'child:', child
						for file in dir.files():
							print file.abspath()
							if file.name.endswith('.hpp') or file.name.endswith('.h'):
								headers_filenames.append(file.relpath_gen(bld.path))
					else:
						for file in bld.cache_dir_contents[dir.id]:
							#print file
							if file.endswith('.hpp') or file.endswith('.h'):
								headers_filenames.append(os.path.join(dir.relpath_gen(bld.path), file))
	#print 'found header files:', headers_filenames
	global APPNAME, VERSION
	for i in includes:
		for h in headers_filenames:
			if h.startswith(i):
				bld.install_as('${PREFIX}/include/' + APPNAME + '-' + VERSION + '/' + h[(len(i)):], h)

def build(bld):
	src_dirs = set(['src'])
	
	# get the dirs generated by genbench
	bld.rescan(bld.path)
	for d in bld.cache_dir_contents[bld.path.id]:
		if d.startswith('src-'): src_dirs.add(d)

	for src in src_dirs:
		lib(bld, 'foo-' + src, ['static', 'shared'], [src + '/foo'], [src])
		program(bld, 'main-' + src, ['static', 'shared'], [src + '/main'], [src], ['foo-' + src])
		install_headers(bld, [src], [src + '/bar'])
	
def shutdown():
	do_lib_version_symlinks()
