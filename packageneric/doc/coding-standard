===============
coding standard
===============

	===
	c++
	===

		- Every declaration is inside a namespace, even preprocessor definitions.

		- Namespaces, types, and functions are written the way of the standard library, that is, lowercase with underscores to separate the words ; e.g. "example::like_this".
		
		- Preprocessor definitions are written the standard, uppercase way, with one underscore to separate two words, and with double-underscores to indicate namespaces, e.g. "EXAMPLE__LIKE_THIS".
		  When ISO C++0x's preprocessor is out, #namespaces directives will be used and double-underscores replaced with the usual "::", e.g. "EXAMPLE::LIKE_THIS".
		  
		- Template parameters are written capitalized with underscores to separate the words, e.g. "template<typename Like_This>".
		
		- No namespace, type, function, or preprocessor definition start with one or several underscores.
		  Names starting with one or several underscores are reserved for the internals of the implementation of the compiler and the standard library.
		
		- On the filesystem, pathnames correspond to the namespaces, types, functions, and preprocessor definitions.
		  The namespace tree is represented on the filesystem by a directory tree where the last compound is either a directory of a file.
		  Files which have the name of a preprocessor definition are named lowercase despite the preprocessor definition being written uppercase.
		  
		- Headers files are given a ".hpp" extension and root source files of translation units a ".cpp" extension.
		  The non-inlined implementation of an interface header file is put in a file with the same basename as the header file, in the same directory.
		  The presence of these implementation root source files being unneeded by clients of the interface headers,
		  it's the job of the "install" target of the makefiles to separate the two, that is:
		  	- to create a "<prefix>/include/<package-tar-name><version>" tree on the filesystem containing the interface header (and inlined implementation) files only,
		  	- to create "<prefix>/lib/<module><version>" library archive files containing the compiled code resulting from the compilation of the implementation root source files as translation units and their linkage.
		
		- Source files which are #included in translation units only, that is, are not #included by any interface header file, are given the extension ".private.hpp".
		  These source files are not part of the "install" target of the makefiles, and thus mustn't be needed by clients in order to be able to use the interface.
		  
		- Header files which are not meant to be #included directly by clients of the interface (i.e., clients only #include a meta header which in turn #includes these headers.) are put in a subdirectory named "detail".
		  These headers are part of the "install" target of the makefiles, and needed by clients in order to be able to use the interface,
		  but the exact pathname corresponding to a specific declaration is not part of the interface.
		  
		- Parts of the sources which only serve implementation purposes but, because this implementation is better to be inlined,
		  are contained in files that the "install" target of the makefiles puts under the "<prefix>/include/<package-tar-name><version>" tree, and hence, visible to the clients,
		  are put under namespaces named "detail", or "DETAIL" for preprocessor definitions.
		  Clients can hence clearly distinguish these parts from the interface and won't use them directly.
		  Generally, these parts are contained in files located under a directory named "detail".

		- The sources must comply with the ISO standard C++ language, but assume the preprocessor supports the #pragma once directive.
		  Language extensions which are specific to a compiler are used thru preprocessor macros which expand either to compiler-specific keywords or to nothing.
		  When a language extension is not absolutely required to achieve some goal, a work arround using only the ISO langage is provided as an alternative,
		  selected when needed using #if preprocessor directives.
		  When a language extension is absolutely required to achieve some goal, the part of the corresponding source is taken away using #if preprocessor directives when unavailable,
		  and, if possible, a dummy implementation is defined instead, or else, clients which need this part of the interface have to use a work around or disable some features.

		- All translation units first include two headers which are #included by the root source file using preprocessor macros as the pathnames:
		  	#include PACKAGENERIC__PRE_COMPILED
		  	#include PACKAGENERIC
		  These preprocessor macros are not defined in the source files themselves, but rather by the build system.
		  For example, the build system may pass the definitions to the preprocessor via -D options on the command line.
		  The sources mustn't assume anything about what the PACKAGENERIC__PRE_COMPILED include brings, i.e. it could simply be /dev/null.
		  The PACKAGENERIC include brings the following preprocessor macros:
		  	#define PACKAGENERIC__PACKAGE__NAME "tar-name-of-the-package"
		  	#define PACKAGENERIC__PACKAGE__DESCRIPTION "Friendly, descriptive name of the package"
		  	#define PACKAGENERIC__PACKAGE__VERSION__MAJOR 1
		  	#define PACKAGENERIC__PACKAGE__VERSION__MINOR 0
		  	#define PACKAGENERIC__PACKAGE__VERSION__PATCH 0
		  	#define PACKAGENERIC__MODULE__NAME "file-name-of-the-module"
		  	#define PACKAGENERIC__MODULE__DESCRIPTION "Friendly, descriptive name of the module"
		  	#define PACKAGENERIC__MODULE__VERSION__INTERFACE__MIN 2  // number passed as argument to the -version-info option on libtool's command line
		  	#define PACKAGENERIC__MODULE__VERSION__INTERFACE__MAX 3  // number passed as argument to the -version-info option on libtool's command line
		  	#define PACKAGENERIC__MODULE__VERSION__IMPLEMENTATION 10 // number passed as argument to the -version-info option on libtool's command line
		  	#define PACKAGENERIC__MODULE__SOURCE__XXX__YYY__ZZZ 1 // because the object xxx/yyy/zzz.o corresponding to the translation unit of xxx/yyy/zzz.cpp is going to be linked in the module being built.
		  	#define PACKAGENERIC__MODULE__SOURCE__AAA__BBB__CCC 1 // because the object aaa/bbb/ccc.o corresponding to the translation unit of aaa/bbb/ccc.cpp is going to be linked in the module being built.
		  	// ... etc for all the root source files whose resulting compiled objects the build system is going to link together.
		  No source must assume to be linked in any particular library archive, so that the build system is free to decide
		  which objects resulting from translation units are linked together in the same library archive, static or dynamic/shared.
		  On MSWindows, this requires either to use gcc's pseudo relocation hack (the --enable-pseudo-relocs command line option),
		  or else, to use, in every interface header, the corresponding preprocessor macro of the series described above to decide wether to import or export the symbols.
		  Using universalis' facilities, this is achieved this way:
		  	For an implementation file xxx/yyy/zzz.cpp:
		  		#include PACKAGENERIC__PRE_COMPILED
		  		#include PACKAGENERIC
		  		#include "zzz.hpp"
		  		namespace xxx
		  		{
		  			namespace yyy
		  			{
		  				zzz   zzz::object_;
		  				
		  				zzz   zzz::hidden_object_;
		  				
		  				zzz & zzz::hidden_object() throw()
		  				{
		  					return hidden_object_; // hidden objects are accessible only from the same module
		  				}
		  				
		  				void zzz::member_function()
		  				{
		  					hidden_member_function(); // hidden functions are accessible only from the same module
		  				}
		  				
		  				void zzz::hidden_member_function()
		  				{
		  					// do something
		  				}
		  				
		  				zzz   object;
		  				
		  				zzz   hidden_object_;
		  				
		  				zzz & hidden_object() throw()
		  				{
		  					return hidden_object_; // hidden objects are accessible only from the same module
		  				}
		  				
		  				void function()
		  				{
		  					hidden_function(); // hidden functions are accessible only from the same module
		  				}
		  				
		  				void hidden_function()
		  				{
							// do something
		  				}
		  			}
		  		}
		  	You would write in its interface header xxx/yyy/zzz.hpp:
		  		#include <foo/bar.hpp>
		  		#include <foo/bars/etc.hpp> // all needed #includes must come before the following lines
		  		#define UNIVERSALIS__COMPILER__DYNAMIC_LINK  PACKAGENERIC__MODULE__SOURCE__XXX__YYY__ZZZ // this #define is a parameter for the following #include
		  		#include <universalis/compiler/dynamic_link/begin.hpp> // will re#define UNIVERSALIS__COMPILER__DYNAMIC_LINK with attribute needed to either import or export the symbols, depending on wether its previous definition evaluated to 0 or not
		  		// from this point,
		  		// 	UNIVERSALIS__COMPILER__DYNAMIC_LINK is either:
		  		// 		for unices (ELF format): no attribute is needed
		  		// 			for gcc, it could be, although useless since it's the default: __attribute__ ((visibility("default")))
		  		// 		for microsoft's operating system (DLL format):
		  		// 			for gcc mingw without the --enable-runtime-pseudo-relocs hack option: __attribute__ ((__dllexport__)) or __attribute__((__dllimport__))
		  		// 			for gcc cygwin and mingw with the --enable-runtime-pseudo-relocs hack option: no attribute is needed, just like on unices
		  		// 			for some other compilers: __declspec(dllexport) or __declspec(dllimport)
		  		// 	UNIVERSALIS__COMPILER__DYNAMIC_LINK__HIDDEN is either:
		  		// 		for unices (ELF format):
		  		// 			for gcc: __attribute__ ((visibility("hidden")))
		  		// 		for microsoft's operating system (DLL format): no attribute is needed since it's the default
		  		namespace xxx
		  		{
		  			namespace yyy
		  			{
		  				class UNIVERSALIS__COMPILER__DYNAMIC_LINK zzz // declaration will implicitely either import or export all non-inline member functions of the class and static objects
			  			{
			  				public:
			  					int const static integer_constant = 123; // integer constants can be defined inline
			  					
			  				public:
				  				void        member_function(); // declaration will implicitely either import or export the definition of the function
				  				void inline_member_function();
				  				
		  					#if PACKAGENERIC__MODULE__SOURCE__XXX__YYY__ZZZ
			  					public:
			  				#else
				  				private: // hidden functions are accessible only from the same module
				  			#endif
			  						void UNIVERSALIS__COMPILER__DYNAMIC_LINK__HIDDEN hidden_member_function(); // declaration will neither import nor export the definition of the function
				  			
				  			public:
				  				zzz static inline & object() throw() { return object_; }
				  			private:
				  				zzz static          object_; // declaration will implicitely either import or export the object
				  				
				  			public:
				  				zzz static                                 & hidden_object(); // declaration will implicitely either import or export the definition of the function
				  			private:
				  				zzz static UNIVERSALIS__DYNAMIC_LINK__HIDDEN hidden_object_ ; // declaration will neither import nor export the object
		  				};
		  				
		  				void UNIVERSALIS__COMPILER__DYNAMIC_LINK                function(); // declaration will either import or export the definition of the function
		  				void inline                                      inline_function();
		  				void UNIVERSALIS__COMPILER__DYNAMIC_LINK__HIDDEN hidden_function(); // declaration will neither import nor export the definition of the function
		  				
		  				int const integer_constant = 123; // integer constants can be defined inline, but,
		  				int const integer_constant; // remember their definition, without a value, must appear in one source file too.

		  				zzz UNIVERSALIS__COMPILER__DYNAMIC_LINK         extern        object  ; // declaration will either import or export the object
		  				zzz UNIVERSALIS__COMPILER__DYNAMIC_LINK__HIDDEN extern hidden_object_ ; // declaration will neither import nor export the object
		  				zzz UNIVERSALIS__COMPILER__DYNAMIC_LINK              & hidden_object() throw();
						
		  				void inline zzz::inline_member_function() // definition is needed because the member function is inline
		  				{
		  					member_function();
		  					object;
		  					object.member_function();
		  					// note that we cannot access hidden functions and objects directly from here
		  					hidden_object(); // access the hidden object via the imported accessor function
		  					hidden_object().member_function();
		  					// we cannot do this: hidden_object().hidden_member_function();
		  					#if PACKAGENERIC__MODULE__SOURCE__XXX__YYY__ZZZ
		  						// in this case, we can access hidden functions and objects directly from here
		  						hidden_function();
		  						object.hidden_member_function();
		  						hidden_object_.hidden_member_function();
		  					#endif
		  				}

		  				void inline inline_function() // definition is needed because the function is inline
		  				{
		  					member_function();
		  					object;
		  					object.member_function();
		  					// note that we cannot access hidden functions and objects directly from here
		  					hidden_object(); // access the hidden object via the imported accessor function
		  					hidden_object().member_function();
		  					// we cannot do this: hidden_object().hidden_member_function();
		  					#if PACKAGENERIC__MODULE__SOURCE__XXX__YYY__ZZZ
		  						// in this case, we can access hidden functions and objects directly from here
		  						hidden_function();
		  						object.hidden_member_function();
		  						hidden_object_.hidden_member_function();
		  					#endif
		  				}
		  			}
		  		}
		  		#include <universalis/compiler/dynamic_link/end.hpp> // will #undef UNIVERSALIS__COMPILER__DYNAMIC__LINK

	===========
	posix shell
	===========
	
	- to avoid hard-coding the aboslute path to the shell executable, start scripts with:
	
	  	#! /usr/bin/env <shell>
	  
	  where <shell> is the basename of a posix-compliant shell that can be found on the PATH environment variable.
	  The env command is part of posix.
