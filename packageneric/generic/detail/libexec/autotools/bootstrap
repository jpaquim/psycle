#! /usr/bin/env sh

########################################################################################################################################
#
# This source is free software ; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation ; either version 2, or (at your option) any later version.
# Copyright ? 1999-2005 Psycledelics http://psycle.pastnotecut.org : Johan Boule
#
# Bootstrap script to generate an autoconf/automake/libtool/pkg-config (autotools) build system
# from only configure.ac and makefile.am files.
#
# This script does things similar to autoconf's autoreconf and anjuta/gnome's autogen.sh scripts.
#
# This script does
#     - check that we have the required tools installed to ensure we will not delete files that we could not regenerate.
#     - delete completly the generated build system files.
#     - generate a new build system from only configure.ac and makefile.am files.
#
# This script requires that you have the following packages installed:
#     autoconf automake libtool (and their dependencies)
#
# You can run a pre-generated build system even if you don't have autoconf, automake and libtool installed
# (you only need g++ make pkg-config);
# but in order to generate the build system, you need autoconf, automake, and libtool.
#
# Note about version control systems:
#
#     If you are getting the sources from a version controled repository,
#     (re)generation of the build system is needed either if
#         - the repository doesn't distribute any of the files generated by this bootstrap process.
#         - some file modification timestamps are inconsistent.
#
#     It is recommended that the repositories do not distribute any generated files,
#     their purpose being to share files amongst developpers, not final distribution, as source packages do.
#
# \meta generic
# \meta standard posix
#
########################################################################################################################################

set -o nounset &&

. $(dirname $0)/../find &&
#. $(dirname $0)/../posix &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

main()
{
	local root=$($(dirname $0)/../root) &&

	echoing "about to bootstrap the autotools build system of the source package $root/" &&
	
	test -f $root/configure.ac ||
	{
		echoing "expected to find file: $root/configure.ac ... bailing out." &&
		false
		return
	} &&

	###########
	# wrappers
	
	if type make 1>/dev/null 2>&1
	then
		if test $(dirname $(which make)) != $root/packageneric/generic/detail/libexec/wrappers
		then
			: #PATH=$root/packageneric/generic/detail/libexec/wrappers:$PATH
		fi
	fi &&

	###########################
	# check for required tools
	{
		if test "${1:-}" != --no-checking-of-required-softwares
		then
			require_softwares
		fi
	} &&

	#########################
	# nested source packages
	{
		if test -e $root/packageneric/package/nested
		then
			for dir in $(eval find $root/packageneric/package/nested -maxdepth 1 $(packageneric__find__dir__no_arch))
			do
				echoing "nested source package $dir/" &&
				if test ! -e $dir/packageneric/generic/bin/autotools.bootstrap
				then
					echoing "not a packageneric package"
				else
					$dir/packageneric/generic/bin/autotools.bootstrap --no-checking-of-required-softwares "$@"
				fi &&
				echoing "poping back to parent source package $root/" ||
				return
			done
		fi
	} &&
	
	########################
	# remove, then generate
	{
		(
			remove
		) &&
		if $(echo "$@" | grep --silent --extended-regexp -- '(--clean|clean)')
		then
			echoing "clean option: We do not generate the new build system."
			echoing "note: You can call $0 to generate the build system files."
		else
			(
				generate
			)
		fi
	}
} &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

############################
# checks for required tools
############################
require_softwares()
{
	echoing "checking for required tools ..." &&
	
	echoing "checking for posix-compliant shell ..." sh $root/packageneric/generic/bin/posix.shell &&
	
	# note about coreutils and fileutils:
	# on msys: uname id are in sh-utils (2.0), and the rest is in fileutils.
	# on fink: uname id are in coreutils, and the rest is in fileutils.
	require_software coreutils fsf-gnu-2.0 uname id &&
	require_software coreutils fsf-gnu-4.1 cp ln mv rm rmdir mkdir ls &&
	
	# formerly textutils
	require_software coreutils fsf-gnu-1.14 cat head tail sort cut wc tr && # note it's 2.0 on most systems, but macosx has antediluvian 1.14
	
	require_software findutils fsf-gnu-4.1 find &&
	require_software grep fsf-gnu-2.4.2 grep &&
	require_software sed fsf-gnu-3.02 sed &&
	require_software diffutils fsf-gnu-2.7 cmp diff diff3 &&
	require_software m4 fsf-gnu-1.4 m4 &&
	require_software perl fsf-gnu-5.6.1 &&
	require_software pkg-config $(grep ^PKG_PROG_PKG_CONFIG $root/packageneric/generic/detail/autotools/autoconf/pkgconfig.ac | sed s/[^0-9\.]//g) pkg-config &&
		# todo: use autoconf --trace=PKG_PROG_PKG_CONFIG instead of grep
	require_software autoconf fsf-gnu-$(grep ^AC_PREREQ $root/packageneric/generic/detail/autotools/autoconf/autoconf.ac | sed s/[^0-9\.]//g) autoconf autoheader autoreconf &&
		# todo: use autoconf --trace=AC_PREREQ instead of grep
	require_software automake fsf-gnu-$(grep ^AM_INIT_AUTOMAKE $root/packageneric/generic/detail/autotools/autoconf/automake.ac | sed 's/.*[( ]\([0-9\.]*\)[ )].*/\1/g') automake aclocal &&
		# todo: use autoconf --trace=AM_INIT_AUTOMAKE instead of grep
	require_software make fsf-gnu-3.79.1 make &&
	require_software libtool fsf-gnu-1.5 libtool libtoolize &&
	{
		require_software g++ fsf-gnu-3.3.5 g++ ||
		require_software g++ fsf-gnu-3.3.5 g++-3.4
	} &&
	echoing "checking for required tools: ok. all required tools are installed." ||
	{
		#echoing "Your PATH env var is: $PATH" &&
		echoing "checking for required tools: missing packages or commands not in path or not compatible or too old (see message above). bailing out." &&
		if test "${PACKAGENERIC__DEV_PACK__MICROSOFT__VERSION:-}"
		then
			echoing "note: Environment variable PSYCLE__DEV_PACK__MICROSOFT__VERSION is set." &&
			echoing "note: If the build fails, this might be because this dev-pack is too old; you can download the latest version from:" &&
			echoing "note: http://psycle.sourceforge.net/dev-pack-for-psycle-on-mswindows/release-notes" &&
			echoing "note: (compare the version with yours which is $PSYCLE__DEV_PACK__MICROSOFT__VERSION)."
		elif test "${OSTYPE:-}" = msys
		then
			echoing "note: Operating system is $OSTYPE." &&
			echoing "note: For this operating system, you can download a complete dev-pack from:" &&
			echoing "note: http://psycle.sourceforge.net/packages/microsoft/dev-pack/release-notes"
		fi
		false
		return
	}
} &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

#############################
# removes build system files
#############################
remove()
{
	# or make distmaint-clean

	echoing "entering source package directory" cd "$root" &&

	if test ! -f configure.ac
	then
		echoing "no configure.ac in this supposedly source package root directory ; skipping removal of the build system files." &&
		return
	fi &&
	
	echoing "removing build system files ..." &&
	
	############################
	# packageneric.autogenerate
	
	echoing "removing build system files ... packageneric.autogenerate" rm --verbose --force --recursive packageneric/+autogenerated &&
	
	###########
	# autoconf
	
	echoing "removing build system files ... autoconf" &&
	
	rm --verbose --force configure &&
	rm --verbose --force --recursive autom4te.cache &&
	
	###########
	# automake
	
	echoing "removing build system files ... automake" &&
	
	for file in $(eval find . $(packageneric__find__file \\\( -iname gnumakefile.am -or -iname makefile.am \\\)))
	do
		file=$(basename $file .am).in &&
		if test -e $file
		then
			rm --verbose --force $file ||
			return
		fi
	done &&
	
	###############################################################
	# automake ... standard package files (automake --add-missing)
	
	if test -L INSTALL # INSTALL describes the standard procedure, and hence should always be a symbolic link.
	then
		rm --verbose --force INSTALL
	fi &&
	if test -L COPYING  # by default, COPYING is a symbolic link to the GPL.
	then
		rm --verbose --force COPYING
	fi &&
	
	##########
	# aclocal
	
	echoing "removing build system files ... aclocal" rm --verbose --force aclocal.m4 &&

	#if type tree 1>/dev/null 2>&1
	#then
	#	echoing "tree" tree -alF $(pwd)
	#fi &&
	
	echoing "note: You now have the minimal package, with only configure.ac and makefile.am files."
} &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

#######################################
# bootstraps autoconf/automake/libtool
#######################################
generate()
{
	local verbose &&

	verbose= &&
	#verbose=--verbose &&
	
	echoing "entering source package directory" cd $root &&    
	echoing "generating new build system from configure.ac and makefile.am files ..." &&
	
	echoing "generating new build system ... packageneric.autogenerate" ./packageneric/generic/detail/libexec/autogenerate/autogenerate &&

	if test -e /usr/share/autoconf-archive
	then
		echoing "generating new build system ... autoconf-archive" &&
		(
			cd packageneric/generic/detail/autotools/autoconf/m4/autoconf-archive &&
			for file in *.m4
			do
				if test ! -L $file -a -e /usr/share/autoconf-archive/$file
				then
					: #ln --symbolic --verbose --force /usr/share/autoconf-archive/$file .
				fi
			done
		)
	fi &&
	
	echoing "generating new build system ... aclocal" aclocal -I packageneric/generic/detail/autotools/autoconf/m4 $verbose &&
		# creates aclocal.m4
	echoing "generating new build system ... auxiliary-programs" mkdir --verbose --parents packageneric/+autogenerated/autotools/auxiliary-programs &&
		# auxiliary build tools sub dir
	echoing "generating new build system ... libtoolize" libtoolize $verbose &&
		# creates links to tools: ltmain.sh config.guess config.sub
	echoing "generating new build system ... autoheader" autoheader $verbose &&
		# creates packageneric/+autogenerated/autotools/autoheader.private.hpp.in as requested in configure.ac
	echoing "generating new build system ... automake" automake $verbose --add-missing &&
		# creates makefile.in files from makefile.am files
		# and creates auxiliary-programs links,
		# and creates links to standard package files: INSTALL COPYING.
	echoing "generating new build system ... autoconf" autoconf $verbose &&
		# creates autom4te.cache and the configure script from configure.ac

	#if type tree 1>/dev/null 2>&1
	#then	
	#	echoing "tree" tree -alF $(pwd)
	#fi &&
	
	echoing "completed sucessfully." &&
	echoing "note: Your package is now ready to run the configure script to generate make files, and then, run make." &&
	echoing "note: You can call '$0 --clean' to remove all the generated files," &&
	echoing "note: and hence get back to the minimal package, with only configure.ac and makefile.am files." &&
	echoing "note: tip: It is unnecessary, and often undesirable, to run configure from within the source tree." &&
	echoing "note: tip: The make files generated by this configure script" &&
	echoing "note: tip: are able to build packages whose source files reside in another tree." &&
	echoing "note: tip: The advantages of building derived files in a separate tree to the source code are fairly obvious:" &&
	echoing "note: tip: the derived files, such as object files, would clutter the source tree" &&
	echoing "note: tip: This would also make it impossible to build those same object files on a different system" &&
	echoing "note: tip: or with a different configuration." &&
	echoing "note: tip: It is recommended to use 3 trees: a source tree, a build tree and an install tree:" &&
	echoing "note: tip: \t mkdir /tmp/build/ && cd /tmp/build/ && $(pwd)/configure --prefix=/tmp/install && make install" &&
	echoing "note: tip: The above commands will keep your $(pwd)/ source package directory clean," &&
	echoing "note: tip: and will install executable program binaries in /tmp/install/bin/ and shared libraries in /tmp/install/lib/" &&
	#echoing "note: tip: To run the executables, in your environement, define the variable export LD_LIBRARY_PATH=/tmp/install/lib/" &&
	#echoing "note: tip: to let the dynamic linker/loader know where to find these shared libraries." &&
	:
} &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

if test x"${BASH:-}" != x
then
	echo='builtin echo'
elif type echo 1>/dev/null 2>&1
then
	echo=$(which echo)
else
	echo='command echo'
fi &&

echo()
{
	$echo "$@"
}
	
echo_custom()
{
	echo -en '\033[1;35m' &&
	echo -e "$@" &&
	echo -en '\033[0m'
} &&

echoing()
{
	local script comment &&
	script_path=packageneric.autotools.$(basename $0) &&
	comment=$1 && shift &&
	echo_custom "$script_path: $comment" &&
	if test $# != 0
	then
		echo_custom "$script_path: -> calling: $@" &&
		"$@"
	fi
} &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

#####################################################
# functions to check that we have the required tools
#####################################################

if type dpkg 1>/dev/null 2>&1
then
	echoing "packaging system: dpkg" &&
	require_software()
	{
		local name version status failed &&
		name=$1 && shift &&
		version=$1 && shift &&
		for command
		do
			require_command_in_path $command $version ||
			{
				failed=true
				break
			}
		done
		test "${failed:-}" != true ||
		{
			echoing "status of dpkg package: $name ..." &&
			status=$(dpkg --status $name 2>/dev/null | grep --extended-regexp '^Status: ' | sed 's/^Status: //') && status="${status:-not-installed}" &&
			echoing "status of dpkg package: $name: $status." &&
			if test "$status" != 'install ok installed'
			then
				if test "$status" = 'not-installed' || test "$(echo $status | cut --delimiter ' ' --fields 3)" = "not-installed"
				then
					echoing "You do not have package $name installed ; you might want to apt-get install $name." &&
					false
					return
				elif test "$(echo $status | cut --delimiter ' ' --fields 3)" = "installed"
				then
					echoing "You have package $name installed, but with oddities." &&
					false
					return
				fi
			fi
		}
	}
elif type rpm 1>/dev/null 2>&1
then
	echoing "packaging system: rpm" &&
	require_software()
	{
		local name version status &&
		name=$1 && shift &&
		version=$1 && shift &&
		echoing "status of rpm package: $name ..." &&
		status=$(rpm --query --queryformat 'installed' $name) || status='not installed' &&
		echoing "status of rpm package: $name: $status." &&
		if test "$status" != installed
		then
			echoing "note: You do not have package $name installed, you might want to apt-get install $name (apt-get or yum or yast)." &&
			: #false
			#return
		fi &&
		local commands="$@" && commands="${commands:-$name}" &&
		for command
		do
			require_command_in_path $command $version ||
			return
		done
	}
elif type cygcheck 1>/dev/null 2>&1
then
	echoing "packaging system: cygcheck" &&
	require_software()
	{
		local name version status &&
		name=$1 && shift &&
		version=$1 && shift &&
		echoing "status of cygwin package: $name ..." &&
		status=$(cygcheck --check-setup $name) &&
		echoing "status of cygwin package: $name: $status." &&
		: # ... todo
	}
else
	echoing "packaging system: none known" &&
	require_software()
	{
		local name version commands &&
		name=$1 && shift &&
		version=$1 && shift &&
		commands="$@" && commands="${commands:-$name}" &&
		for command
		do
			require_command_in_path $command $version ||
			return
		done
	}
fi &&

require_command_in_path()
{
	local name version version__string version__number &&
	name=$1 && shift &&
	version=$1 && shift &&
	version__string=$(echo $version | sed 's/^\([^0-9]*\)-.*/\1/') && 
	version=$(echo $version | sed 's/^[^0-9]*//') &&
	echo -n $(echoing "checking for command: $name ...") &&
	if type $name 1>/dev/null 2>&1
	then
		echo_custom -n "$(which $name) --version: " &&
		{
			$name --version 1>/dev/null 2>&1 &&
			if test "$version__string" = fsf-gnu
			then
				$name --version | grep --extended-regexp --silent '(GNU|Free Software Foundation)' &&
				echo_custom -n 'FSF-GNU ' ||
				{
					echo_custom -n 'warning: not the Free Software Foundation GNU version. ' &&
					false
				}
			fi
		} &&
		version__string="$($name --version | head -n 1)" &&
		version__number="$(echo $version__string | sed 's/[^0-9\. ][0-9\.]*//g' | sed 's/^[^0-9]*//' | cut -d ' ' -f 1)" &&
		echo_custom -n "$version__number. " &&
		if expr "$version__number" '<' "$version" 1>/dev/null
		then
			echo_custom "error: too old: required version is at least $version." &&
			false
			return
		else
			echo_custom "0k (>= $version)."
		fi
	else
		echo_custom 'error: not found in path.' &&
		false
		return
	fi ||
	{
		echo_custom 'warning: failed to determine version.'
	}
} &&

#####################################################################################################
#####################################################################################################
#####################################################################################################

main "$@" ||
{
	echoing "failed for source package $($(dirname $0)/../root)/" &&
	false
}
