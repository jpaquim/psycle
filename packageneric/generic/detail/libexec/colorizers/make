#! /usr/bin/perl

###############################################################################
#
# This source is free software ; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation ; either version 2, or (at your option) any later version.
# copyright 1999-2007 psycledelics http://psycle.pastnotecut.org : johan boule
#
# modified by johan boule
# based on ...
#
###############################################################################
#
# colormake.pl 0.3
#
# Copyright: (C) 1999, Bjarni R. Einarsson <bre@netverjar.is>
#                      http://bre.klaki.net/
# 
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
###############################################################################

use Cwd 'abs_path';
use IPC::Open3;

$col_norm =	        "\033[0m";
$col_black =        "\033[30m";
$col_red =          "\033[31m";
$col_green =        "\033[32m";
$col_brown =        "\033[33m";
$col_blue =         "\033[34m";
$col_purple =       "\033[35m";
$col_cyan =         "\033[36m";
$col_ltgray =       "\033[37m";
$col_background =   "\033[07m";
$col_brighten =     "\033[01m";
$col_underline =    "\033[04m";
$col_blink = 	    "\033[05m";

# Customize colors here...
$col_default =      "";
$col_gcc =          $col_purple . $col_brighten;
$col_ld =           $col_cyan . $col_brighten;
$col_make =         $col_green;
$col_make_warning = $col_brown . $col_brighten;
$col_make_error =   $col_red . $col_brighten;
$col_echo =         $col_ltgray;

$make = '/usr/bin/make';
$make_options_when_tty = '--silent';

# if we're writing to something that's not a tty, don't do color.
# <bohan> or if we've called ourself recursively
if(! -t STDOUT || $ENV{"TERM"} eq 'color-pipe')
{
	exec $make, @ARGV
	or die("Couldn't exec");
}
else
{
	# <bohan>
	$ENV{"TERM"} = 'color-pipe';
}

# <bohan>
# copied from colorgcc.
if($0 =~ m#(.*)/#)
{
	# We were called with an explicit path, so find our dir and tweak the PATH to add it.
	my $dirname = $1;
	$dirname = abs_path($1) unless $dirname =~ m#^/#;
	$ENV{"PATH"} = "$dirname:" . $ENV{"PATH"};
}

# <bohan>
# Disable any locale, so that we are ensured to parse the english messages.
$ENV{"LC_ALL"} = 'C';

# Keep the pid of the make process so we can get its return
# code and use that as our return code.
$make_pid = open3('<&STDIN', \*MAKEOUT, \*MAKEOUT, $make, $make_options_when_tty, @ARGV);
#$make_pid = open3('<&STDIN', \*MAKEOUT, \*MAKEOUT, $make, @ARGV);

# Colorize the output from make.
$in = 'unknown';
while(<MAKEOUT>)
#while (<>)
{
	$orgline = $thisline = $_;
	
	# Remove multiple spaces
	$thisline =~ s/  \+/ /g;
	
	if($thisline =~ s/^((GNUm|M|m)akefile:([0-9]+:)?\swarning:.*)$/$col_make_warning$1$col_norm/x)
	{
		$in = 'make';
	}
	elsif($thisline =~ s/^((p|g)?make(\[[0-9]+\])?: .* (Error|Stop).*)$/$col_make_error$1$col_norm/x)
	{
		$in = 'make';
	}
	# make[1]: Entering directory `/blah/blah/blah'
	elsif($thisline =~ s/^((p|g)?make(\[[0-9]+\])?: .*)$/$col_make$1$col_norm/x)
	{
		$in = 'make';
	}
	elsif($thisline =~ s/^(Making .+ in .*)$/$col_make$1$col_norm/x)
	{
		$in = 'make';
	}
	elsif($thisline =~ s/^ *((g?cc|(g|c)\+\+|windres).*)$/$col_echo$1$col_norm/) 
	{
		$in = 'gcc';
	}
	elsif($thisline =~ s/^(.* \.lo .*)$/$col_gcc$1$col_norm/) 
	{
		$in = 'gcc';
	}
	elsif($thisline =~ s/^(.* \.la .*)$/$col_ld$1$col_norm/) 
	{
		$in = 'gcc';
	}
	elsif($thisline =~ s/^(.* \.exe .*)$/$col_ld$1$col_norm/) 
	{
		$in = 'gcc';
	}
	elsif($thisline =~ s/^(echo .*)/$col_echo$1$col_norm/x)
	{
		$in = 'echo';
	}
	elsif($thisline =~ s/^(_+)$/$col_make$col_brighten$1$col_norm/x)
	{
		$in = 'make';
	}
	elsif($thisline =~ s/^(\#+ .*)$/$col_make$col_brighten$1$col_norm/x)
	{
		$in = 'make';
	}
	elsif($thisline =~ /^(\(|\[|a(r|wk)|c(p|d|h(mod|own))|do(ne)?|e(cho|lse)|f(ind|or)|i(f|nstall)|mv|perl|r(anlib|m(dir)?)|s(e(d|t)|trip)|tar)\s+/)
	{
		$in = $1;
	}
	elsif($in eq 'gcc')
	{
		# let colorgcc handle the line
	}
	
	if($thisline !~ /^\s+/) 
	{
		print $col_norm, $col_default;
	}	
	print $thisline;	
}
print $col_norm;

# Get the return code of make and exit with that.
waitpid($make_pid, 0);
exit ($? >> 8);







#!/bin/bash

###############################################
#
# Wrapper around make, to colorize its output.
#
###############################################

#/usr/bin/$(basename $0) "$@" 2>&1 | $0.colorizing-filter
#exit ${PIPESTATUS[0]}
