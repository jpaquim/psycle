#!/bin/bash

##############################################################################
#
# Bootstrap script to generate an autoconf/automake/libtool/pkg-config (autotools) build system
# from only configure.ac and makefile.am files.
#
# This script does things similar to autoconf's autoreconf and anjuta/gnome's autogen.sh scripts.
#
# This script does
#     - (re)create the symbolic links that cvs might have discarded.
#     - check that we have the required tools installed to ensure we will not delete files that we could not regenerate.
#     - run 'make distclean' if there exists a generated make file, or else, manually remove files generated by configure.
#       (note that you can call configure from any directory outside of the package directory itself so that the latter stay clean)
#     - delete completly any existant generated build system files.
#     - generate a new build system from configure.ac and makefile.am files.
#
# This script requires that you have the following packages installed:
#     apt-get install g++ make autoconf automake libtool
#
# You can run a pre-generated build system even if you don't have autoconf/automake/libtool/pkg-config installed
# (you only need to apt-get install g++ make);
# but in order to generate the build system, you need to apt-get install autoconf automake libtool pkg-config.
#
# Note about gnu-arch or cvs:
#
#     If you are getting the sources from a gnu-arch or cvs repository,
#     (re)generation of the build system is needed either if
#         - the repository doesn't distribute any of the files generated by autoconf/automake/libtool/pkg-config.
#         - cvs (not gnu-arch) updates made some file timestamps inconsistent.
#
#     It is recommended that the repository does not distribute any generated files,
#     the role of gnu-arch and cvs being concurent versionning control amongst developpers,
#     not distribution, as source packages do.
#
#
# Copyright (C) 2004 Johan Boulé
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
##############################################################################

function main
{
	absolute_name=$(absolute-name $0) &&
	package_directory=$(dirname $absolute_name) &&
	build_directory=$(pwd) &&
	echo-custom "$(basename $0): About to bootstrap the autotools build system of the source package $package_directory/" &&
	{
		links --verbose $*
	} &&
	{
		echo-custom "$(basename $0): Checking required tools..."
		require-software g++ g++ &&
		require-software make make &&
		require-software m4 m4 &&
		require-software autoconf autoconf autoheader &&
		require-software automake automake aclocal &&
		require-software libtool libtool libtoolize &&
		require-software pkg-config pkg-config &&
		echo-custom "$(basename $0): Ok. All required tools are installed." ||
		{
			echo-custom "$(basename $0): Missing packages or commands not in path. Aborting."
			false
			return
		}
	} &&
	{
		clean --verbose $* &&
		remove --verbose $* &&
		if test "$1" = --do-not-generate
		then
			echo-custom -e \
				"$(basename $0): $1 option: We don't generate the new build system." \
				"\n$(basename $0): You can call $absolute_name to generate the build system files." &&
			return
		fi &&
		generate $*
	}
}

if test $(which readlink)
then
	function absolute-name
	{
		readlink --canonicalize --no-newline $1
	}
else
	function absolute-name
	{
		local name=$1 &&
		pushd 1>/dev/null $(dirname $name) &&
		{
			local ok=true
			{
				echo $(dirs -l +0)/$(basename $name)
			} || ok=false
			popd 1>/dev/null
			test "$ok" = true
		}
	}
fi

function echo-custom
{
	echo -en '\e[1m'
	echo $*
	echo -en '\e[0m'
}

#####################################################
# functions to check that we have the required tools
#####################################################

if test $(which dpkg)
then
	function require-software
	{
		name=$1 && shift
		status=$(dpkg --status $name 2> /dev/null | grep -e '^Status: ' | sed 's/^Status: //')
		echo-custom "$(basename $0): Status of dpkg package: $name: $status";
		if test "$status" != "install ok installed"
		then
			echo-custom "$(basename $0): You don't have package $name installed." #, please apt-get install $name"
			false
			#return
		fi
		for i do
			require-command-in-path $i
		done
	}
elif test $(which rpm)
then
	function require-software
	{
		name=$1 && shift
		status=$(rpm --query --queryformat 'installed' $name) || status='not installed'
		echo-custom "$(basename $0): Status of rpm package: $name: $status"
		if test "$status" != "installed"
		then
			echo-custom "$(basename $0): You don't have package $name installed." #, please apt-get install $name (apt-get or yum)"
			false
			#return
		fi
		for i do
			require-command-in-path $i ||
			{
				false
				return
			}
		done
	}
else
	function require-software
	{
		name=$1 && shift
		echo-custom "$(basename $0): Packaging system: none known."
		for i do
			require-command-in-path $i ||
			{
				false
				return
			}
		done
	}
fi

function require-command-in-path
{
	name=$1
	if test $(which $name)
	then
		status="found"
		message="command $name found in path at $(which $name), version: $($name --version | head --lines 1)"
	else
		status="not found"
		message="command $name not found in path: $PATH"
	fi
	echo-custom "$(basename $0): Status of command: $name: $message"
	if test "$status" != "found"
	then
		echo-custom "$(basename $0): You don't have $name in your path: $PATH"
		false
	fi
}

##################################################
# DistCleans using the makefile, if any, or else,
# manually removes files generated by configure
##################################################
function clean
{
	for i do
		if test "$i" = --verbose
		then
			local verbose=--verbose
		else
			local verbose=
		fi
	done &&
	echo-custom $(basename $0): Entering build directory: $build_directory/ &&
	cd $build_directory/ &&
	if test -f makefile -o -f Makefile
	then # we have a generated make file, so we use it to distclean
		echo-custom $(basename $0): Calling: make distclean...
		make distclean ||
		{
			echo-custom "$(basename $0): Failed. Removing the broken make file to make sure it has gone, and retrying..."
			rm $verbose --force {M,m}akefile
			clean $*
		}
	else
		echo-custom "$(basename $0): There is no make file. Manually removing files generated by configure..."
		rm $verbose --force config.status config.lineno config.log config.cache config.{h,H,hh,hpp,hxx} stamp-{h,h1} libtool
		find ./ -follow -type f -iname makefile -exec rm $verbose --force {} \;
	fi
	true # never mind if it fails.
}

#############################
# Removes build system files
#############################
function remove
{    
	for i do
		if test "$i" = --verbose
		then
			local verbose=--verbose
		else
			local verbose=
		fi
	done &&
	echo-custom $(basename $0): Entering source package directory: $package_directory/ &&
	cd $package_directory/ &&
	echo-custom "$(basename $0): Removing build system files..." &&
	
	############################################################################################################
	# configure (files generated by configure, but in the source package directory, not in the build directory)
	
	rm $verbose --force confdefs.h &&


	################################
	# auxiliary build tools sub dir

	#rm $verbose --force --recursive autotools.auxiliary-programs &&
	
	###########
	# autoconf
	
	rm $verbose --force configure stamp-h.in &&
	rm $verbose --force --recursive autom4te.cache &&
	
	#############
	# autoheader
	
	rm $verbose --force config.{h,H,hh,hpp,hxx}.in &&
	
	###########
	# automake
	
	find ./ -follow -type f -iname makefile.in -exec rm $verbose --force {} \; &&
	rm $verbose --force missing depcomp install-sh &&
	rm $verbose --force mkinstalldirs  && # automake <= 1.4
	
	##########
	# libtool
	
	rm $verbose --force ltmain.sh config.guess config.sub &&
	
	##################################################
	# standard package files (automake --add-missing)
	
	if test -L INSTALL # INSTALL describes the standard procedure, and hence should always be a symbolic link.
	then
		rm $verbose --force INSTALL
	fi &&
	if test -L COPYING  # by default, COPYING is a symbolic link to the GPL.
	then
		rm $verbose --force COPYING
	fi &&
	
	##########
	# aclocal
	
	rm $verbose --force aclocal.m4 &&
	
	#if test $(which tree)
	#then
	#	echo-custom $(basename $0): Calling: tree &&
	#	tree -alF $(pwd)
	#fi &&
	
	echo-custom "$(basename $0): You now have the minimal package, with only configure.ac and makefile.am files."
}

############################################################
# cvs does not handle symbolic links, so we (re)create them
############################################################
function links
(
	for i do
		if test "$i" = --verbose
		then
			local verbose=--verbose
		else
			local verbose=
		fi
	done &&
	echo-custom $(basename $0): Entering source package directory: $package_directory/ &&
	cd $package_directory/ &&
	echo-custom "$(basename $0): (Re)creating symbolic links that cvs might have discarded..." &&
	ln $verbose --symbolic ../../README ../../AUTHORS ../../NEWS ../../ChangeLog ./ 2>/dev/null
	ln $verbose --symbolic ../../src ../../include ./ 2>/dev/null
	true # the links might already exist.
)

#######################################
# bootstraps autoconf/automake/libtool
#######################################
function generate
{
	for i do
		if test "$i" = --verbose
		then
			local verbose=--verbose
		else
			local verbose=
		fi
	done &&
	echo-custom $(basename $0): Entering source package directory: $package_directory/ &&
	cd $package_directory/ &&    
	echo-custom "$(basename $0): Generating new build system from configure.ac and makefile.am files..." &&
	
	echo-custom "$(basename $0): Calling: aclocal" &&
	aclocal $verbose && # creates aclocal.m4
	
	echo-custom "$(basename $0): Calling: libtoolize" &&
	libtoolize && # creates links to tools: ltmain.sh config.guess config.sub
	
	echo-custom "$(basename $0): Calling: autoheader" &&
	autoheader && # creates config.{h,H,hh,hpp,hxx}.in from configure.ac
		# todo: why to we have to call autoheader explicitely? should be called automatically by autoconf

	echo-custom "$(basename $0): Calling: automake --add-missing" &&
	automake $verbose --add-missing &&
		# creates makefile.in files from makefile.am files
		# and creates links to tools: missing depcomp install-sh (and mkinstalldirs for automake <= 1.4),
		# and to standard package files: INSTALL COPYING,
		# and implicitely calls libtoolize --automake to create links to tools: ltmain.sh config.guess config.sub
		# todo: why do we have to call libtoolize explicitely? should be called automatically by automake
	
	echo-custom "$(basename $0): Calling: autoconf" &&
	autoconf $verbose && # creates autom4te.cache and the configure script from configure.ac

	#if test $(which tree)
	#then	
	#	echo-custom "$(basename $0): Calling: tree" &&
	#	tree -alF $(pwd)
	#fi &&
	
	echo-custom -e \
		"$(basename $0): Completed sucessfully." \
		"\n$(basename $0): Your package is now ready to run the configure script to generate make files, and then, run make." \
		"\n$(basename $0): You can call $absolute_name --do-not-generate to remove all the generated files," \
		"\n$(basename $0): and hence get back to the minimal package, with only configure.ac and makefile.am files." \
		"\n$(basename $0): Tip:" \
		"\n$(basename $0): It is unnecessary, and often undesirable, to run configure from within the source tree." \
		"\n$(basename $0): Instead, a well-written make file generated by configure" \
		"\n$(basename $0): will be able to build packages whose source files reside in another tree." \
		"\n$(basename $0): The advantages of building derived files in a separate tree to the source code are fairly obvious:" \
		"\n$(basename $0): the derived files, such as object files, would clutter the source tree" \
		"\n$(basename $0): This would also make it impossible to build those same object files on a different system" \
		"\n$(basename $0): or with a different configuration." \
		"\n$(basename $0): It is recommended to use 3 trees: a source tree, a build tree and an install tree:" \
		"\n$(basename $0): \t mkdir /tmp/build/ && cd /tmp/build/ && $(pwd)/configure --prefix=/tmp/install && make install" \
		"\n$(basename $0): The above commands will keep your $(pwd)/ source package directory clean," \
		"\n$(basename $0): and will install any executable in /tmp/install/bin/ and any shared library in /tmp/install/lib/" \
		"\n$(basename $0): To run the executables, in your environement, define the variable export LD_LIBRARY_PATH=/tmp/install/lib/" \
		"\n$(basename $0): to let the shared library loader know where to find these shared libraries." \
		"\n$(basename $0): Note: this is the only way to build if you have symbolic links to source directories!" \
		||
	{
		echo-custom $(basename $0): Failed.
		false
	}
}

##################################################################
# now that all functions are defined, we can excuted the main one
main $*
