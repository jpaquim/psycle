//////////////////////////////////////////////////////////////////////
//
//				Main.cpp ( Core Machine Interface Implementation )
//
//				druttis@darkface.pp.se
//
//////////////////////////////////////////////////////////////////////

#include "Main.h"

//////////////////////////////////////////////////////////////////////
//
//				Parameters
//
//////////////////////////////////////////////////////////////////////

#define NUM_PARAM_ROWS 1
#define NUM_PARAM_COLS 1

#define NUM_PARAMS (NUM_PARAM_ROWS * NUM_PARAM_COLS)

//////////////////////////////////////////////////////////////////////
//
//				Parameters
//
//////////////////////////////////////////////////////////////////////

#define PARAM_DUMMY 0
CMachineParameter const param0 =
{
	"Dummy",
	"Dummy parameter",
	0,
	1,
	MPF_STATE,
	0
};

//////////////////////////////////////////////////////////////////////
//
//				Parameter list
//
//////////////////////////////////////////////////////////////////////

CMachineParameter const *pParams[] =
{
	&param0
};

//////////////////////////////////////////////////////////////////////
//
//				Machine info
//
//////////////////////////////////////////////////////////////////////

CMachineInfo const MacInfo =
{
	MI_VERSION,
	GENERATOR,
	NUM_PARAMS,
	pParams,
#ifdef _DEBUG
	MAC_NAME " " MAC_VERSION " (Debug)",
#else
	MAC_NAME " " MAC_VERSION,
#endif
	MAC_NAME,
	MAC_AUTHOR " on " __DATE__,
	"Command Help",
	NUM_PARAM_COLS
};

//////////////////////////////////////////////////////////////////////
//
//				Machine class
//
//////////////////////////////////////////////////////////////////////

class mi : public CMachineInterface
{

	//////////////////////////////////////////////////////////////////
	//
	//				Variables
	//
	//////////////////////////////////////////////////////////////////

private:

	//////////////////////////////////////////////////////////////////
	//
	//				Generic for synth
	//
	//////////////////////////////////////////////////////////////////

#ifdef __GENERATOR__
	GLOBALS				globals;
	Track				tracks[MAX_TRACKS][MAX_VOICES];
#endif

	//////////////////////////////////////////////////////////////////
	//
	//				Properties
	//
	//////////////////////////////////////////////////////////////////

	int								internal_tick_length;

	int								ticks_remaining;

	//////////////////////////////////////////////////////////////////
	//
	//				Methods
	//
	//////////////////////////////////////////////////////////////////

public:

	mi();
	virtual ~mi();
	virtual void Init();
	virtual void Stop();
	virtual void Command();
	virtual void ParameterTweak(int par, int val);
	virtual bool DescribeValue(char* txt,int const param, int const value);
	virtual void SequencerTick();
	virtual void SeqTick(int channel, int note, int ins, int cmd, int val);
	virtual void Work(float *psamplesleft, float* psamplesright, int numsamples, int numtracks);

	//////////////////////////////////////////////////////////////////
	//
	//				GetSamplingRate
	//
	//////////////////////////////////////////////////////////////////
	
	__forceinline int GetSamplingRate()
	{
		return pCB->GetSamplingRate() * oversampling_level;
	}

	//////////////////////////////////////////////////////////////////
	//
	//				GetTickLength
	//
	//////////////////////////////////////////////////////////////////
	
	__forceinline int GetTickLength()
	{
		return pCB->GetTickLength() * oversampling_level;
	}

};

DLL_EXPORTS

//////////////////////////////////////////////////////////////////////
//
//				Constructor
//
//////////////////////////////////////////////////////////////////////

mi::mi()
{
	//////////////////////////////////////////////////////////////////
	//
	//				Required construction code
	//
	//////////////////////////////////////////////////////////////////

	Vals = new int[NUM_PARAMS];
	internal_tick_length = DEFAULT_INTERNAL_TICK_LENGTH;

#ifdef __GENERATOR__
	for (int ti = 0; ti < MAX_TRACKS; ti++)
	{
		for (int vi = 0; vi < MAX_VOICES; vi++)
		{
			tracks[ti][vi].globals = &globals;
		}
	}
#endif

	Stop();

	//////////////////////////////////////////////////////////////////
	//
	//				Add construction code below
	//
	//////////////////////////////////////////////////////////////////

}

//////////////////////////////////////////////////////////////////////
//				Destructor
//////////////////////////////////////////////////////////////////////

mi::~mi()
{
	//////////////////////////////////////////////////////////////////
	//
	//				Required destructor code
	//
	//////////////////////////////////////////////////////////////////

	delete Vals;

	//////////////////////////////////////////////////////////////////
	//
	//				Add destructor code below
	//
	//////////////////////////////////////////////////////////////////
}

//////////////////////////////////////////////////////////////////////
//
//				Init
//
//////////////////////////////////////////////////////////////////////

void mi::Init()
{
	//////////////////////////////////////////////////////////////////
	//
	//				Change init code below
	//
	//////////////////////////////////////////////////////////////////
}

//////////////////////////////////////////////////////////////////////
//
//				Stop
//
//////////////////////////////////////////////////////////////////////

void mi::Stop()
{
	//////////////////////////////////////////////////////////////////
	//
	// Required stop code
	//
	//////////////////////////////////////////////////////////////////

#ifdef __GENERATOR__
	for (int ti = 0; ti < MAX_TRACKS; ti++)
	{
		for (int vi = 0; vi < MAX_VOICES; vi++)
		{
			tracks[ti][vi].NoteStop();
		}
	}
#endif

	ticks_remaining = internal_tick_length;

	//////////////////////////////////////////////////////////////////
	//
	//				Add stop code below
	//
	//////////////////////////////////////////////////////////////////
	

}

//////////////////////////////////////////////////////////////////////
//
//				Command
//
//////////////////////////////////////////////////////////////////////

void mi::Command()
{
	pCB->MessBox(
		"Yo!",
		MAC_AUTHOR " " MAC_NAME " v." MAC_VERSION,
		0
	);
}

//////////////////////////////////////////////////////////////////////
//
//				ParameterTweak
//
//////////////////////////////////////////////////////////////////////

void mi::ParameterTweak(int par, int val)
{
	//////////////////////////////////////////////////////////////////
	//
	//				Required code
	//
	//////////////////////////////////////////////////////////////////

	Vals[par] = val;

	//////////////////////////////////////////////////////////////////
	//
	//				Add code below
	//
	//////////////////////////////////////////////////////////////////
}

//////////////////////////////////////////////////////////////////////
//
//				DescribeValue
//
//////////////////////////////////////////////////////////////////////

bool mi::DescribeValue(char* txt,int const param, int const value)
{
	//////////////////////////////////////////////////////////////////
	//
	//				Add code below
	//
	//////////////////////////////////////////////////////////////////

	return false;
}

//////////////////////////////////////////////////////////////////////
//
//				SequencerTick
//
//////////////////////////////////////////////////////////////////////

void mi::SequencerTick()
{
	//////////////////////////////////////////////////////////////////
	//
	//				Required code
	//
	//////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////
	//
	//				Add code below for effects
	//
	//////////////////////////////////////////////////////////////////
}

//////////////////////////////////////////////////////////////////////
//
//				SequencerTick
//
//////////////////////////////////////////////////////////////////////

void mi::SeqTick(int channel, int note, int ins, int cmd, int val)
{
	//////////////////////////////////////////////////////////////////
	//				Required code
	//////////////////////////////////////////////////////////////////

#ifdef __GENERATOR__

	globals.samplingrate = GetSamplingRate();
	globals.ticklength = GetTickLength();

	int vol = 254;

	//////////////////////////////////////////////////////////////////
	//				Process command
	//////////////////////////////////////////////////////////////////

	switch (cmd)
	{
		case 0x0c:				//				Volume
			vol = val - 2;
			if (vol < 0)
				vol = 0;
			break;

		//////////////////////////////////////////////////////////////
		//				Custom code
		//////////////////////////////////////////////////////////////
	}

	//////////////////////////////////////////////////////////////////
	//				Route
	//////////////////////////////////////////////////////////////////

	if (note == 120)
	{
		tracks[channel][0].NoteOff();
	}
	else if (note < 120)
	{
		if (cmd == 0x0d)
		{

		}
		else
		{
			tracks[channel][0].NoteOff();
			tracks[channel][1] = tracks[channel][0];
			tracks[channel][0].NoteOn(note, (float) vol / 256.0f);
			tracks[channel][0].ticks_remaining = 0;
		}
	}

	//////////////////////////////////////////////////////////////////
	//
	//				Required code
	//
	//////////////////////////////////////////////////////////////////

#endif

}

//////////////////////////////////////////////////////////////////////
//				Work
//////////////////////////////////////////////////////////////////////

void mi::Work(float *psamplesleft, float* psamplesright, int numsamples, int numtracks)
{
	//////////////////////////////////////////////////////////////////
	//				Variables
	//////////////////////////////////////////////////////////////////

	int ti;
	int vi;
	int amount;
	int amt;
	int nsamples;
	float *pleft;
	float *pright;

	//////////////////////////////////////////////////////////////////
	//				Save original arguments
	//////////////////////////////////////////////////////////////////

	float *s_psamplesleft = psamplesleft;
	float *s_psamplesright = psamplesright;
	int s_numsamples = numsamples;

	//////////////////////////////////////////////////////////////////
	//				Setup for oversampling if neccesary
	//////////////////////////////////////////////////////////////////

	if (oversampling_level > 1)
	{
		psamplesleft = pbufleft;
		psamplesright = pbufright;
		numsamples *= oversampling_level;

		Dsp::Fill(psamplesleft, 0.0f, numsamples);
		Dsp::Fill(psamplesright, 0.0f, numsamples);
	}

	//////////////////////////////////////////////////////////////////
	//				Trim pointers
	//////////////////////////////////////////////////////////////////

	--psamplesleft;
	--psamplesright;

	//////////////////////////////////////////////////////////////////
	//				Begin generate
	//////////////////////////////////////////////////////////////////

	do
	{

		//////////////////////////////////////////////////////////////
		//				Global tick handling
		//////////////////////////////////////////////////////////////

		if (!ticks_remaining)
		{
			ticks_remaining = internal_tick_length * oversampling_level;
			/* GlobalUpdate(); */
		}

		//////////////////////////////////////////////////////////////
		//				Compute amount of samples to render for all voices
		//////////////////////////////////////////////////////////////

		amount = numsamples;
		if (amount > ticks_remaining)
		{
			amount = ticks_remaining;
		}

		//////////////////////////////////////////////////////////////
		//				Render all voices now
		//////////////////////////////////////////////////////////////

		for (ti = 0; ti < numtracks; ti++)
		{
			for (vi = 0; vi < MAX_VOICES; vi++)
			{
				if (tracks[ti][vi].IsActive())
				{
					pleft = psamplesleft;
					pright = psamplesright;
					nsamples = amount;
					do
					{
						//////////////////////////////////////////////
						//				Voice tick handing
						//////////////////////////////////////////////

						if (!tracks[ti][vi].ticks_remaining)
						{
							tracks[ti][vi].ticks_remaining = internal_tick_length * oversampling_level;
							tracks[ti][vi].Update();
						}

						//////////////////////////////////////////////
						//				Compute amount of samples to render this voice
						//////////////////////////////////////////////

						amt = nsamples;
						if (amt > tracks[ti][vi].ticks_remaining)
						{
							amt = tracks[ti][vi].ticks_remaining;
						}

						//////////////////////////////////////////////
						//				Render voice now
						//////////////////////////////////////////////

						tracks[ti][vi].Work(pleft, pright, amt);

						//////////////////////////////////////////////
						//				Adjust for next voice iteration
						//////////////////////////////////////////////

						tracks[ti][vi].ticks_remaining -= amt;
						pleft += amt;
						pright += amt;
						nsamples -= amt;
					} while (nsamples);
				}
			}
		}

		//////////////////////////////////////////////////////////////
		//				Adjust for next iteration
		//////////////////////////////////////////////////////////////

		ticks_remaining -= amount;
		psamplesleft += amount;
		psamplesright += amount;
		numsamples -= amount;

	} while (numsamples);

	//////////////////////////////////////////////////////////////////
	//				Do down sampling if neccesary
	//////////////////////////////////////////////////////////////////

	if (oversampling_level > 1)
	{
		downsample(pbufleft, s_psamplesleft, s_numsamples, oversampling_level, sinc);
		downsample(pbufright, s_psamplesright, s_numsamples, oversampling_level, sinc);
	}

}
