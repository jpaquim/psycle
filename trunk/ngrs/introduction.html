<html>
<head>

<title>
ngrs introduction
</title>

<meta http-equiv='Content-Type' content='text/html; charset=iso-8859-1'>
<meta name='title' content='NattiSoft'>
<meta name='author' content='NattiSoft'>
<meta name='copyright' content='NattiSoft'>
<meta name='description' content='NattiSoft'>

<style type='text/css'>
html, th, div, p, h1, h2, .def { font-family: Verdana, Tahoma, Arial; color:#ffffff; font-size:15px; }
h1 { font-size:24px; }
h2 { font-size:18px; }
table { border-collapse:collapse; }
td { font-family: Verdana, Tahoma, Arial; color:#ffffff; font-size:13px; vertical-align:top; }
p { padding:8; }
a:link { color:#FBC800; text-decoration:none; }
a:visited { color:#FBC800; text-decoration:none; }
a:hover { color:#FBC800; text-decoration:underline; }
a.menu:link { color:#416247; text-decoration:none; font-family: Helvetica; font-size:17px; }
a.menu:visited { color:#416247; text-decoration:none; font-family: Helvetica; font-size:17px; }
a.menu:hover { color:#FBC800; text-decoration:none; font-family: Helvetica; font-size:17px;  }
a.bottom:link { color:#416247; text-decoration:none; font-size:13px; }
a.bottom:visited { color:#416247; text-decoration:none; font-size:13px; }
a.bottom:hover { color:#FBC800; text-decoration:underline; font-size:13px; }
.t10 { background-color:#707070; color:#ffffff; }
.t11 { background-color:#585858; color:#d0d0d0; }
.t12 { background-color:#505050; color:#d0d0d0; }
.cgi { font-size:14px; }
span.topic { font-family: Verdana, Tahoma, Arial; color:#ffffff; font-size:18px; vertical-align:top; }
span.menu_text { font-family: Helvetica; font-size:17px; color:#000000; }
span.tail { font-family:  Verdana, Tahoma, Arial; font-size:12px; color:#000000; }
</style>

</head>

<body bgcolor='#556C5A' text='#ffffff'>

<h2>NGRS Programming introduction</h2>
<h5>(c) 2004,2005,2006 Nattisoft www.nattisoft.de</h5>

<h2>Quick start</h2>
Each ngrs app runs in an own xlib gui thread, using internally a select main loop.
To start writing an ngrs app, you need 3 steps todo:
<p>
1. create a NApp app object<br>
2. create a main window dereived from NWindow and assign it to the NApp object<br>
3. start the mainloop with app.run()<br>
</p>
<p>
Example (1.1) : displaying a window
<pre>
#include &lt;napp.h&gt;
#include &lt;nwindow.h&gt;

int main(int argc, char *argv[])
{
  NApp app;

  NWindow* myMainWindow = new NWindow();
  app.setMainWindow(myMainWindow);
  app.run();

  return EXIT_SUCCESS;
}
</pre>
<p>Writing an App</p>
<p>
Each ngrs app needs a mainwindow, that will be act as parent for every gui element, and closing this window,will delete every childwindow and element in it.
So your first step will be, to create a derevided class of NWindow.<p>
Example (1.2) : deriving a window
<pre>
#include &lt;nwindow.h&gt;

class MainWindow : public NWindow {
public:
  MainWindow() {};
  ~MainWindow() {};
};

#include &lt;napp.h&gt;
#include &lt;mainwindow.h&gt;

int main(int argc, char *argv[])
{
  NApp app;

  NWindow* myMainWindow = new MainWindow();
  app.setMainWindow(myMainWindow);
  app.run();

  return EXIT_SUCCESS;
}
</pre>
</p>

After having a derived class, you can now fill the window content in this ctor.<br>
Example (1.3) : setting up the window content in the ctor using example 1.2

<pre>
    MainWindow() {
       setTitle("My program");
       setPosition(10,10,500,500);    
    };
</pre>

</p>
<p>Adding a menu</p>
Now you can go further e.g adding an Menu. An main menu is created with a menuBar, and menu`s you add to the bar. The menu`s itself contain menuitems.<br>
Example (1.4) : adding a menubar with some entries.

<pre>
    #include &lt;nmenubar.h&gt;
    #include &lt;nmenu.h&gt;
    #include &lt;nmenuitem.h&gt;

    MainWindow() {
1       setTitle("My program");
2       setPosition(10,10,500,500);    
3       NMenuBar* menuBar = new NMenuBar();
4          NMenu* fileMenu = new NMenu("File"); 
5             NMenuItem* exitItem = new NMenuItem("quit");
6             fileMenu->add(exitItem);
7          menuBar->add(fileMenu);
8       pane()->add(menuBar);
    };
</pre>

"pane()" gets a ptr to the root window container, that can contain visualcomponents (like menubar`s , buttons, label, etc ..)
In line 8 we add the menuBar to the pane. Due to the nested structure of visualcomponents, we can now add like in the pane, to the menuBar a menu. and a menu will then again contain menuitems. The method is always add.

<p>
Using signals
</p>
ngrs uses a callback technique called signals. E.g a menuItem has a signal "clicked", wich will be emit an signal, if somebody selected this item. To react on such a signal you need a socalled callback function, that will connect to the signal, and will then be called by the signal.
Example (1.5) : adding a signal to a menuitem

<pre>
   NMenuItem* exitItem = new NMenuItem("quit");
      exitItem->clicked.connect(this,&MainWindow::onMenuItemClicked);
      
  
  
   MainWindow::onMenuItemClicked(NButtonEvent* ev) {
      exit(0);
   }    
</pre>

<p>Some gui elements</p>
How to use <h2 align="center"> <img src="nbutton.png" width="108" height="28" border="0" alt="" align="left"> NButton Overview</h2>
<hr>
<h3>Common usage</h3>
<ul>
	<li>A single button will wait for a click, and then call the connected clicked event Method.</li>
	<li>A single (toggle)button is acting as on/off-switch and will remain in status down till you press the button again </li>
	<li>Several buttons working in a group as on/off-switch together. Pressing a button in this group, will switch up the previous selected button in that group.</li>
</ul>
<h3>Get it to working</h3>
You can create a Button in two ways. <p>
NButton* btn = new NButton(); or <br>
NButton* btn = new NButton("press me");
<p>
The button text can now be changed using setText()<p>
btn->setText("click me!");<br>
<p>
If you are working in a form use pane->add(btn) or if you are working in a component class use add(btn);<br>
You can connect a method to the clicked signal of the button. If you connecting a method outside the class, you have to replace the this with an instance pointer of the class that implements the method<p>
<pre>
btn->clicked.connect(this,&amp;myClass::btnPressed);

void myClass::btnPressed(NButtonEvent* ev) {
   // do all you want when the button was pressed.
}
</pre>

How to use <h2 align="center"> <img src="nedit.png" width="108" height="28" border="0" alt="" align="left"> NEdit Overview</h2>
<hr>
<h3>Common usage</h3>
<ul>
	<li>An nedit is a one line input box, which allows you to enter text with one Font.</li>	
</ul>

<h3>Get it working</h3>
First you should create an edit. <p>
NEdit* edt = new NEdit();
NEdit* edt = new NEdit("Hallo");

<p>
If you are working in a form use pane->add(edt) or if you are working in a component class use add(edt);<br>
You can connect a method to the keyPressed signal of the nedit. If you connecting a method outside the class, you have to replace the this with an instance pointer of the class that implements the method
<p>

<pre>

</pre>
<p>
<img src="filedialog.png"  border="0" alt="" align="left"> <br clear="all">
<p>
<h3>Get it to work</h3>
A NFileDialog is a window wich will be created with new NFileDialog(). With "add" you add the dialog to another window. 
<p>
<pre>
NFileDialog* dialog;

// somewhere in the constructor
dialog = new NFileDialog(); 
add(dialog);
</pre>

<p>
<pre>
Lets create a button that will open the filedialog
NButton* btn = new NButton();
pane->add(btn);
btn->clicked.connect(this,&amp;myClass::btnPressed);

void myClass::btnPressed(NButtonEvent* ev) {
  if (dialog->execute()) { /*loadFile for e.g */ } else { //do nothing }
}
</pre>

<p>
  dialog->execute() will start the dialog, stop the rest of the program, will wait till ok or cancel was pressed and return true or false depending if the ok or cancel button was pressed.
  <p>
in future:
With  dialog->dir() you get the dir, with dialog->filename() you get the filename without dir and with dialog->dirFilename() you get the filename including the full path.
atm : fileName() has the full dir path..
</body>
</html>