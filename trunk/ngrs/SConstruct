#! /usr/bin/env scons

# This source is free software ; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation ; either version 2, or (at your option) any later version.
# copyright 2006 johan boule <bohan@jabber.org>
# copyright 2006 psycledelics http://psycle.pastnotecut.org

# To be able to import the packageneric package, we add the parent dir of this SConstruct file to the python path:
import sys, os, os.path
sys.path.append(os.path.split(os.getcwd())[0]) # SCons always makes the dir of the SConstruct file the current dir.

# project

from packageneric.generic.scons.project import project
project = project(name = 'ngrs')

# authors/maintainers/uploaders

from packageneric.generic.scons.person import person
prodos = person('Stefan NattKemper', 'natti__@user.sourceforge.net')
bohan = person('Johan Boule', 'bohan.packageneric@retropaganda.info')

# source package

from packageneric.generic.scons.source_package import source_package
from packageneric.generic.scons.version import version
source_package = source_package(project,
	name = 'ngrs',
	version = version(0, 0),
	description = 'ngrs graphic toolkit library',
	long_description = """\
ngrs is a graphic toolkit library ...
This library is used by xpsycle."""
)

# external packages

from packageneric.generic.scons.check.external_package import external_package as external_package_check
from packageneric.generic.scons.check.pkg_config import pkg_config as pkg_config_check
from packageneric.generic.scons.check.cxx_build import cxx_build as cxx_build_check

from packageneric.pool.stdcxx import stdcxx
stdcxx = stdcxx(project)

from packageneric.pool.dlfcn import dlfcn
dlfcn = dlfcn(project)

pthread = external_package_check(project, name = 'pthread',
	dependencies = [
		cxx_build_check(project, name = 'pthread', libraries = ['pthread'], source_text = \
			"""\
				#include <pthread.h>
				void pthread()
				{
					pthread_t self(pthread_self());
				}
			"""
		)
	],
	distribution_packages = {
		'debian and ubuntu': 'libc-dev (>= 0)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...'
	},
	url = 'http://google.ch posix 1003.1-2003'
)

freetype = external_package_check(project, name = 'freetype',
	dependencies = [
		pkg_config_check(project, name = 'freetype2 >= 0') # note: brings the z lib
	],
	distribution_packages = {
		'debian': 'libfreetype6-dev (>= 0)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...',
		'microsoft': '... (have a look at http://gimp.org)'
	},
	url = 'http://google.ch ...'
)

class x(external_package_check):
	def __init__(self):
		external_package_check.__init__(self, project, name = 'x',
			dependencies = [],
			distribution_packages = {
				'debian and ubuntu': 'libx11-dev (>= 0)',
				'gentoo': '...',
				'fedora': '...',
				'cygwin': '...'
			},
			url = 'http://x.org'
		)
	def dynamic_dependencies(self):
		# debian has a pkg-config file for it, but it's not sure for other distributions. todo use pkg-config with a build check as fallback
		#pkg_config_check(project, name = 'x11 >= 0')
		class x_build_check(cxx_build_check):
			def __init__(self, fucked_up_path = False):
				if fucked_up_path:
					name = 'x with fucked up path'
					cxx_compiler_paths = ['/usr/X11R6/include']
					library_paths = ['/usr/X11R6/lib']
				else:
					name = 'x'
					cxx_compiler_paths = []
					library_paths = []
				cxx_build_check.__init__(self, project, name = name, libraries = ['X11'], cxx_compiler_paths = cxx_compiler_paths, library_paths = library_paths, source_text = \
					"""\
						#include <X11/Xlib.h>
						void x()
						{
							Display * display(XOpenDisplay(0));
							XCloseDisplay(display);
						}
					"""
				)
		x = x_build_check()
		if not x.result(): x = x_build_check(fucked_up_path = True)
		self.add_dependency(x)
x = x()

xfixes = external_package_check(project, name = 'xfixes',
	dependencies = [
		# debian has a pkg-config file for it, but it's not sure for other distributions. todo use pkg-config with a build check as fallback
		#pkg_config_check(project, name = 'xfixes >= 0')
		cxx_build_check(project, name = 'xfixes', dependencies = [x], libraries = ['Xfixes'], source_text = \
			"""\
				#include <X11/Xlib.h>
				#include <X11/extensions/Xfixes.h>
				void xfixes()
				{
					// todo do something with it for a complete check
				}
			"""
		)
	],
	distribution_packages = {
		'debian and ubuntu': 'libxfixes-dev (>= 0)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...'
	},
	url = 'http://x.org'
)

xpm = external_package_check(project, name = 'xpm',
	dependencies = [
		# debian has a pkg-config file for it, but it's not sure for other distributions. todo use pkg-config with a build check as fallback
		#pkg_config_check(project, name = 'xpm >= 0')
		cxx_build_check(project, name = 'xpm', dependencies = [x], libraries = ['Xpm'], source_text = \
			"""\
				#include <X11/xpm.h>
				void xpm()
				{
					// todo do something with it for a complete check
				}
			"""
		)
	],
	distribution_packages = {
		'debian and ubuntu': 'libxpm-dev (>= 0)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...'
	},
	url = 'http://x.org'
)

xcursor = external_package_check(project, name = 'xcursor',
	dependencies = [
		# debian has a pkg-config file for it, but it's not sure for other distributions. todo use pkg-config with a build check as fallback
		#pkg_config_check(project, name = 'xcursor >= 0')
		cxx_build_check(project, name = 'xcursor', dependencies = [x], libraries = ['Xcursor'], source_text = \
			"""\
				#include <X11/Xlib.h>
				#include <X11/Xcursor/Xcursor.h>
				void xcursor()
				{
					// todo do something with it for a complete check
				}
			"""
		)
	],
	distribution_packages = {
		'debian and ubuntu': 'libxcursor-dev (>= 0)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...'
	},
	url = 'http://x.org'
)

xft = external_package_check(project, name = 'xft',
	dependencies = [
		pkg_config_check(project, name = 'xft >= 0')
	],
	distribution_packages = {
		'debian and ubuntu': 'libxft2-dev (>= 0), libfontconfig1-dev (>= 2.3.1)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...'
	},
	url = 'http://x.org'
)

xerces = external_package_check(project, name = 'xerces',
	dependencies = [
		cxx_build_check(project, name = 'xerces', libraries = ['xerces-c'], source_text = \
			"""\
				#include <xercesc/sax/Parser.hpp>
				void xerces()
				{
					// todo do something with it for a complete check
				}
			"""
		)
	],
	distribution_packages = {
		'debian and ubuntu': 'libxerces27-dev (>= 0) | libxerces26-dev (>= 0)',
		'gentoo': '...',
		'fedora': '...',
		'cygwin': '...'
	},
	url = 'http://apache.org'
)

# modules

from packageneric.generic.scons.module import module

class ngrs_module(module):
	def __init__(self):
		module.__init__(self, source_package,
			name = 'ngrs-' + str(source_package.version().major()),
			version = source_package.version(),
			description = source_package.description(),
			dependencies = [stdcxx, xerces]
		)

	def dynamic_dependencies(self):
		# todo here we should check whether we have dlfcn, pthread and the X window libraries (and related),
		# if not and if the host operating system is microsoft's, this shouldn't be a fatal error
		# (once ngrs supports that os too, that is).
		# remove the ' or True' when ready
		
		if dlfcn.result() or True: self.add_dependency(dlfcn)
		else: pass # todo for other systems

		if pthread.result() or True: self.add_dependency(pthread)
		else: pass # todo for other systems

		if freetype.result() or True: self.add_dependency(freetype)
		else: pass # todo work around?

		if x.result() or True:
			self.add_dependency(x)
			
			if xfixes.result() or True: self.add_dependency(xfixes)
			else: pass # todo work around?

			if xpm.result() or True: self.add_dependency(xpm)
			else: pass # todo work around?

			if xcursor.result() or True: self.add_dependency(xcursor)
			else: pass # todo work around?

			if xft.result() or True: self.add_dependency(xft)
			else: pass # todo work around?
		else: pass # todo for other systems

ngrs_module = ngrs_module()

from packageneric.generic.scons.find import find
ngrs_module.add_sources(find(project, 'src', 'ngrs', '*.cpp'))
ngrs_module.add_headers(find(project, 'src', 'ngrs', '*.hpp'))
ngrs_module.add_headers(find(project, 'src', 'ngrs', '*.h'))

ngrs_module.contexes().source().compilers().cxx().paths().add(['src'])

# pkg-config packages

from packageneric.generic.scons.pkg_config_package import pkg_config_package
ngrs_package = pkg_config_package(project,
	name = 'ngrs-' + str(ngrs_module.version().major()),
	version = ngrs_module.version(),
	description = ngrs_module.description(),
	modules = [ngrs_module]
)

if False:
	# debian

	from packageneric.generic.scons.debian_package import debian_package

	ngrs_runtime = debian_package(project,
		name = 'lib-ngrs-' + str(source_package.version().major()),
		section = 'libs',
		description = ngrs_package.description(),
		long_description = 'This package contains the runtime library.'
	)
	#ngrs_runtime.add_files(ngrs_package.binaries())

	class ngrs_dev(debian_package):
		def __init__(self):
			debian_package.__init__(self, project,
				name = ngrs_runtime.name() + '-dev',
				section = 'libdevel',
				description = ngrs_package.description(),
				long_description = 'This package contains the development files.',
			)
		def dynamic_dependencies(self):
			self.add_depend(ngrs_runtime)
			self.add_build_depends(ngrs_package.build_depends())
	ngrs_dev = ngrs_dev()
	#ngrs_dev.add_files(ngrs_package.headers())
	#ngrs_dev.add_files(ngrs_package.pkg_config())

	ngrs_doc = debian_package(project,
		name = ngrs_runtime.name() + '-doc',
		section = 'doc',
		architecture = 'all',
		description = ngrs_package.description(),
		long_description = 'This package contains the documentation.'
	)

	from packageneric.generic.scons.debian import debian
	debian = debian(source_package,
		maintainer = prodos,
		uploaders = [prodos, bohan],
		binary_packages = [ngrs_runtime, ngrs_dev, ngrs_doc],
	)

project(ngrs_package)

Return('ngrs_package')
