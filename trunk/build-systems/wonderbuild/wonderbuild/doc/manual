===========================================================

Some doc for the ModTask class:

	Method __call__(self, sched_ctx):
		This is where to check for the availability of the dependencies.
		Dependencies are instances of the ModDepPhases.
		These are tasks that once processed, are convertible to a boolean.
		Required and optionally found dependencies should be put in self.public_deps and self.private_deps.
		Dependencies that are used in public headers should be put in self.public_deps, and the others in self.private_deps.
	
	Method do_mod_phase(self):
		This is where to set self.sources and self.cfg for building the object files.

	Attribute cxx_phase:
		This should be a task that installs the public headers so that clients can start building their object files.

	Method apply_cxx_to(self, cfg):
		This is where to export flags to the cfg so that clients can start building their object files.
		For example: adding to cfg.include_paths the path where the cxx_phase installed the headers.
	
Some doc for the PreCompileTasks class:

	Method __call__(self, sched_ctx):
		This is where to check for the availability of the dependencies, just like in the ModTask class,
		but a pch should have only optional dependencies, put in self.public_deps.

	Property source_text(self):
		This property should return the actual code to precompile.
		For example, a series of #include.
	
	Method do_cxx_phase(self):
		This is where to set self.cfg for building the pch file.
		For example: self.cfg.include_paths

===========================================================

X.setup_deps (__call__)
X.build_objs (do_mod_phase)
X.install_headers (cxx_phase)
X.client_cxx_flags (apply_cxx_to) -> X.install_headers
X.build_mod -> X.setup_deps
            -> X.build_objs
X.client_mod_flags -> X.build_mod
X.deep_deps = self.cfg.shared or not self.cfg.static_prog
X.ld = shared or prog

A -> B -> C

A {static, dyn} prog
{B, C} {static, shared/loadable} lib

A static, B static, C static: A -> B -> C
A dyn, B static, C static: A -> B -> C
A dyn, B static, C shared: A -> B -> C
A dyn, B shared, C static: A -> B (rarely used)
A dyn, B shared, C shared: A -> B

A.build_mod -> A.setup_deps -> B.setup_deps -> C.setup_deps
            -> A.build_objs -> B.client_cxx_flags -> B.install_headers
                                                  -> C.client_cxx_flags -> C.install_headers
            -> A.ld? -> B.client_mod_flags -> B.build_mod -> B.setup_deps -> C.setup_deps
                                                          -> B.build_objs -> C.client_cxx_flags -> C.install_headers
                                                          -> B.ld? -> C.client_mod_flags -> C.build_mod -> C.setup_deps
                                                                                                        -> C.build_objs
                                           -> !B.ld? -> C.client_mod_flags

===========================================================

The core of wonderbuild is the task.

Step 0:
A task is supposed to run only once in a build run.
The scheduler stores a boolean attribute in each task to flag the tasks that have been evaluated
and simply skips the tasks scheduled for execution that have already been evaluated.

Step 1:
A task first compare its inputs with the inputs of the last time it was executed.
Since the old inputs don't exist anymore, this means a task need compute and store a signature of its inputs to a persistent storage,
and compare this signature with the signature of the current inputs.

Step 2:
If the old input signature is different from the new signature (or if there was no previous signature),
the task need to do its actual job.

Step 3:
Upon successful completion, the task then stores the signature of the inputs to the persistent storage.
If a error occurred, the task doesn't update the persistent input signature, so that the next build run will try again.
_________________________________________

all: foo

foo1.o: foo1.c
	cc -c -o foo1.o foo1.c

foo2.o: foo2.c
	cc -c -o foo2.o foo2.c

foo: foo1.o foo2.o
	cc -o foo foo1.o foo2.o

_________________________________________

from wonderbuild.task import Task
from wonderbuild.script import ScriptTask

class WonderBuild(ScriptTask):

	def __call__(self, sched_ctx):
		project = self.project
		
		tasks = {}

		class MakeLikeTask(Task):
			def __init__(self, outputs, inputs, commands):
				Task.__init__(self)
				for o in outputs:
					tasks[o] = self
					project.add_task_alias(o, self)
				self.outputs = outputs
				self.inputs = inputs
				self.commands = commands

			def __call__(self, shed_ctx):
				input_tasks = []
				for i in self.inputs:
					try: input_tasks.append(tasks[i])
					except KeyError: pass
				for x in sched_ctx.parallel_wait(*input_tasks): yield x
				min_output = min([(project.bld_dir / o).time for o in self.outputs])
				max_input = max([(project.src_dir / i).time for i in self.inputs])
				try: sched_ctx.release()
					if min_output < max_input:
						for c in self.commands: exec_subprocess(c)
				finally: sched_ctx.acquire()
				for o in self.outputs: o.clear()

		foo1 = MakeLikeTask(['foo1.o'], ['foo1.c'], ['cc -o foo1.o foo1.c'.split()])
		foo2 = MakeLikeTask(['foo2.o'], ['foo2.c'], ['cc -o foo2.o foo2.c'.split()])
		foo = MakeLikeTask(['foo'], ['foo1.o', 'foo2.o'], ['cc -o foo foo1.o foo2.o'.split()])
		project.default_tasks.append(foo)

